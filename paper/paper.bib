

@inproceedings{Allais2018a,
  author    = {Guillaume Allais},
  title     = {Typing with Leftovers - {A} mechanization of Intuitionistic Multiplicative-Additive
               Linear Logic},
  booktitle = {{TYPES}},
  series    = {LIPIcs},
  volume    = {104},
  pages     = {1:1--1:22},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik},
  year      = {2017},
  doi       = {10.4230/LIPIcs.TYPES.2017.1},
  timestamp = {Tue, 11 Feb 2020 15:52:14 +0100},
  biburl    = {https://dblp.org/rec/conf/types/Allais17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{BarendsenS96,
  title = {Uniqueness Typing for Functional Languages with Graph Rewriting Semantics},
  author = {Barendsen, Erik and Smetsers, Sjaak},
  year = {1996},
  volume = {6},
  pages = {579--612},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/journals/mscs/BarendsenS96.bib},
  journal = {Math. Struct. Comput. Sci.},
  number = {6},
  timestamp = {Wed, 01 Apr 2020 08:48:44 +0200}
}

@article{Bernardy2018,
  title = {Linear Haskell: {{Practical}} Linearity in a Higher-Order Polymorphic Language},
  author = {Bernardy, Jean-Philippe and Boespflug, Mathieu and Newton, Ryan R. and Peyton Jones, Simon and Spiwack, Arnaud},
  year = {2017},
  month = dec,
  volume = {2},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3158093},
  articleno = {Article 5},
  issue_date = {January 2018},
  journal = {Proc. ACM Program. Lang.},
  number = {POPL},
  numpages = {29}
}

@inproceedings{Dardha14,
  title = {Recursive Session Types Revisited},
  booktitle = {{{BEAT}}},
  author = {Dardha, Ornela},
  editor = {Carbone, Marco},
  year = {2014},
  volume = {162},
  pages = {27--34},
  doi = {10.4204/EPTCS.162.4},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/journals/corr/Dardha14.bib},
  note = {\url{https://doi.org/10.4204/EPTCS.162.4}},
  series = {{{EPTCS}}},
  timestamp = {Wed, 14 Nov 2018 10:31:26 +0100}
}

@inproceedings{DardhaGS12,
  title = {Session Types Revisited},
  booktitle = {{{PPDP}}},
  author = {Dardha, Ornela and Giachino, Elena and Sangiorgi, Davide},
  year = {2012},
  doi = {10.1145/2370776.2370794},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  optaddress = {New York, NY, USA},
  optpages = {139-150},
  optpublisher = {ACM}
}

@article{DardhaGS17,
  title = {Session Types Revisited},
  author = {Dardha, Ornela and Giachino, Elena and Sangiorgi, Davide},
  year = {2017},
  volume = {256},
  pages = {253--286},
  doi = {10.1016/j.ic.2017.06.002},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/journals/iandc/DardhaGS17.bib},
  journal = {Inf. Comput.},
  note = {\url{https://doi.org/10.1016/j.ic.2017.06.002}},
  timestamp = {Fri, 31 Jan 2020 14:19:02 +0100}
}

@article{Girard87,
  title = {Linear Logic},
  author = {Girard, Jean-Yves},
  year = {1987},
  month = jan,
  volume = {50},
  pages = {1--102},
  publisher = {{Elsevier Science Publishers Ltd.}},
  address = {{GBR}},
  issn = {0304-3975},
  doi = {10.1016/0304-3975(87)90045-4},
  issue_date = {January 1987},
  journal = {Theoretical Computer Science},
  note = {\url{https://doi.org/10.1016/0304-3975(87)90045-4}},
  number = {1},
  numpages = {102}
}

@inproceedings{H93,
  title = {Types for Dyadic Interaction},
  booktitle = {{{CONCUR}}},
  author = {Honda, Kohei},
  year = {1993},
  volume = {715},
  pages = {509--523},
  publisher = {{Springer}},
  doi = {10.1007/3-540-57208-2_35},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  biburl = {http://dblp.uni-trier.de/rec/bib/conf/concur/Honda93},
  opturl = {http://dx.doi.org/10.1007/3-540-57208-2{$_3$}5},
  series = {{{LNCS}}}
}

@inproceedings{HVK98,
  title = {Language Primitives and Type Disciplines for Structured Communication-Based Programming},
  booktitle = {{{ESOP}}},
  author = {Honda, Kohei and Vasconcelos, Vasco and Kubo, Makoto},
  year = {1998},
  doi = {10.1007/BFb0053567},
  optpages = {22\textendash{}138},
  optpublisher = {Springer},
  optseries = {LNCS},
  optvolume = {1381}
}

@inproceedings{HYC08,
  title = {Multiparty Asynchronous Session Types},
  booktitle = {{{POPL}}},
  author = {Honda, Kohei and Yoshida, Nobuko and Carbone, Marco},
  year = {2008},
  doi = {10.1145/1328438.1328472},
  optbibsource = {DBLP, http://dblp.uni-trier.de},
  optee = {http://doi.acm.org/10.1145/1328438.1328472},
  optpages = {273-284},
  optpublisher = {ACM},
  optvolume = {43(1)}
}

@inproceedings{K02bis,
  title = {Type Systems for Concurrent Programs},
  booktitle = {10th Anniversary Colloquium of {{UNU}}/{{IIST}}},
  author = {Kobayashi, Naoki},
  year = {2002},
  doi = {10.1007/978-3-540-40007-3_26},
  optpages = {439-453}
}

@unpublished{K07,
  title = {Type Systems for Concurrent Programs},
  author = {Kobayashi, Naoki},
  year = {2007},
  note = {\url{http://www.kb.ecei.tohoku.ac.jp/~koba/papers/tutorial-type-extended.pdf}}
}

@inproceedings{KPT96,
  title = {Linearity and the Pi-Calculus},
  booktitle = {{{POPL}}},
  author = {Kobayashi, Naoki and Pierce, Benjamin C. and Turner, David N.},
  year = {1996},
  doi = {10.1145/237721.237804},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  biburl = {http://dblp.uni-trier.de/rec/bib/conf/popl/KobayashiPT96},
  optpages = {358\textendash{}371},
  optpublisher = {ACM},
  opturl = {http://doi.acm.org/10.1145/237721.237804}
}

@inproceedings{MatsakisK14,
  title = {The Rust Language},
  booktitle = {{{HILT}}},
  author = {Matsakis, Nicholas D. and II, Felix S. Klock},
  year = {2014},
  pages = {103--104},
  publisher = {{ACM}},
  doi = {10.1145/2663171.2663188},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/conf/sigada/MatsakisK14.bib},
  timestamp = {Tue, 06 Nov 2018 16:57:53 +0100}
}

@book{Milner99,
  title = {Communicating and Mobile Systems: The {{$\pi$}}-{{Calculus}}},
  author = {Milner, Robin},
  year = {1999},
  month = may,
  publisher = {{Cambridge University Press}},
  isbn = {0 521 64320 1 (hc), 0 521 65869 1 (pbk)}
}

@article{MilnerPW92,
  title = {A Calculus of Mobile Processes, Parts {{I}} and {{II}}},
  author = {Milner, Robin and Parrow, Joachim and Walker, David},
  year = {1992},
  volume = {100},
  doi = {10.1016/0890-5401(92)90008-4},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  biburl = {http://dblp.uni-trier.de/rec/bib/journals/iandc/MilnerPW92a},
  journal = {Inf. Comput.},
  number = {1},
  optpages = {1\textendash{}77},
  opturl = {http://dx.doi.org/10.1016/0890-5401(92)90008-4},
  timestamp = {Thu, 15 Jan 2015 17:11:51 +0100}
}

@article{Padovani17,
  title = {A Simple Library Implementation of Binary Sessions},
  author = {Padovani, Luca},
  year = {2017},
  volume = {27},
  publisher = {{Cambridge University Press}},
  doi = {10.1017/S0956796816000289},
  journal = {Journal of Functional Programming}
}

@inproceedings{Rouvoet2020,
  title = {Intrinsically-Typed Definitional Interpreters for Linear, Session-Typed Languages},
  booktitle = {Proceedings of the 9th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Rouvoet, Arjen and Bach Poulsen, Casper and Krebbers, Robbert and Visser, Eelco},
  year = {2020},
  month = jan,
  pages = {284--298},
  publisher = {{ACM}},
  address = {{New Orleans LA USA}},
  doi = {10.1145/3372885.3373818},
  file = {/home/uma/.zotero/data/storage/S6IALUBR/Rouvoet et al_2020_Intrinsically-typed definitional interpreters for linear, session-typed.pdf},
  isbn = {978-1-4503-7097-4},
  language = {en},
  note = {\url{https://dl.acm.org/doi/10.1145/3372885.3373818}}
}

@book{Sangio01,
  title = {The {{$\pi$}}-Calculus: A Theory of Mobile Processes},
  author = {Sangiorgi, Davide and Walker, David},
  year = {2001},
  publisher = {{Cambridge University Press}}
}

@inproceedings{ScalasDHY17,
  title = {A Linear Decomposition of Multiparty Sessions for Safe Distributed Programming},
  booktitle = {{{ECOOP}}},
  author = {Scalas, Alceste and Dardha, Ornela and Hu, Raymond and Yoshida, Nobuko},
  year = {2017},
  volume = {74},
  pages = {24:1-24:31},
  publisher = {{Schloss Dagstuhl - Leibniz-Zentrum f{\"u}r Informatik}},
  doi = {10.4230/LIPIcs.ECOOP.2017.24},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/conf/ecoop/ScalasDHY17.bib},
  note = {\url{https://doi.org/10.4230/LIPIcs.ECOOP.2017.24}},
  series = {{{LIPIcs}}},
  timestamp = {Fri, 27 Mar 2020 08:51:54 +0100}
}

@inproceedings{ScalasY16,
  title = {Lightweight Session Programming in Scala},
  booktitle = {{{ECOOP}}},
  author = {Scalas, Alceste and Yoshida, Nobuko},
  year = {2016},
  doi = {10.4230/LIPIcs.ECOOP.2016.21},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  biburl = {http://dblp.uni-trier.de/rec/bib/conf/ecoop/ScalasY16},
  optpages = {21:1\textendash{}21:28},
  optpublisher = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik},
  optseries = {LIPIcs},
  opturl = {http://dx.doi.org/10.4230/LIPIcs.ECOOP.2016.21},
  optvolume = {56},
  timestamp = {Wed, 20 Jul 2016 15:20:05 +0200}
}

@article{Thiemann2019,
  title = {Intrinsically-{{Typed Mechanized Semantics}} for {{Session Types}}},
  author = {Thiemann, Peter},
  year = {2019},
  month = aug,
  abstract = {Session types have emerged as a powerful paradigm for structuring communication-based programs. They guarantee type soundness and session fidelity for concurrent programs with sophisticated communication protocols. As type soundness proofs for languages with session types are tedious and technically involved, it is rare to see mechanized soundness proofs for these systems. We present an executable intrinsically typed small-step semantics for a realistic functional session type calculus. The calculus includes linearity, recursion, and recursive sessions with subtyping. Asynchronous communication is modeled with an encoding. The semantics is implemented in Agda as an intrinsically typed, interruptible CEK machine. This implementation proves type preservation and a particular notion of progress by construction.},
  archivePrefix = {arXiv},
  eprint = {1908.02940},
  eprinttype = {arxiv},
  file = {/home/uma/.zotero/data/storage/V4EXAH8L/Thiemann_2019_Intrinsically-Typed Mechanized Semantics for Session Types.pdf;/home/uma/.zotero/data/storage/VIS2P5XN/1908.html},
  journal = {arXiv:1908.02940 [cs]},
  keywords = {Computer Science - Programming Languages},
  note = {\url{http://arxiv.org/abs/1908.02940}},
  primaryClass = {cs}
}

@inproceedings{THK94,
  title = {An Interaction-Based Language and Its Typing System},
  booktitle = {{{PARLE}}},
  author = {Takeuchi, Kaku and Honda, Kohei and Kubo, Makoto},
  year = {1994},
  volume = {817},
  pages = {398--413},
  publisher = {{Springer}},
  doi = {10.1007/3-540-58184-7_118},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  biburl = {http://dblp.uni-trier.de/rec/bib/conf/parle/TakeuchiHK94},
  opturl = {http://dx.doi.org/10.1007/3-540-58184-7{$_1$}18},
  series = {{{LNCS}}}
}

@inproceedings{Veltri2020,
  title = {Formalizing {$\pi$}-Calculus in Guarded Cubical {{Agda}}},
  booktitle = {Proceedings of the 9th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Veltri, Niccol{\`o} and Vezzosi, Andrea},
  year = {2020},
  month = jan,
  pages = {270--283},
  publisher = {{ACM}},
  address = {{New Orleans LA USA}},
  doi = {10.1145/3372885.3373814},
  abstract = {Dependent type theories with guarded recursion have shown themselves suitable for the development of denotational semantics of programming languages. In particular Ticked Cubical Type Theory (TCTT) has been used to show that for guarded labelled transition systems (GLTS) interpretation into the denotational semantics maps bisimilar processes to equal values. In fact the two notions are proved equivalent, allowing one to reason about equality in place of bisimilarity.},
  file = {/home/uma/.zotero/data/storage/JNSFACP4/Veltri and Vezzosi - 2020 - Formalizing -calculus in guarded cubical Agda.pdf},
  isbn = {978-1-4503-7097-4},
  language = {en},
  note = {\url{https://dl.acm.org/doi/10.1145/3372885.3373814}}
}

@inproceedings{Wadler90,
  title = {Linear Types Can Change the World!},
  booktitle = {Programming Concepts and Methods},
  author = {Wadler, Philip},
  year = {1990},
  pages = {561},
  publisher = {{North-Holland}},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/conf/ifip2/Wadler90.bib},
  timestamp = {Mon, 21 Jan 2019 18:52:11 +0100}
}

@article{Zalakain2020Agda,
  title = {Typing the {{Linear}} {{$\pi$}}-Calculus \textendash{} {{Formalisation}} in {{Agda}}},
  author = {Zalakain, Uma and Dardha, Ornela},
  year = {2020},
  note = {\url{https://github.com/umazalakain/typing-linear-pi}}
}

@inproceedings{deBruijn1972,
  title = {Lambda {{Calculus Notation}} with {{Nameless Dummies}}, a {{Tool}} for {{Automatic Formula Manipulation}}, with {{Application}} to the {{Church}}-{{Rosser Theorem}}},
  booktitle = {Indagationes {{Mathematicae}} ({{Proceedings}})},
  author = {{de Bruijn}, Nicolaas Govert},
  year = {1972},
  volume = {75},
  pages = {381--392},
  publisher = {{Elsevier}}
}

@inproceedings{Gay2001,
  title = {A {{Framework}} for the {{Formalisation}} of {{Pi Calculus Type Systems}} in {{Isabelle}}/{{HOL}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  author = {Gay, Simon J.},
  editor = {Boulton, Richard J. and Jackson, Paul B.},
  year = {2001},
  pages = {217--232},
  publisher = {{Springer Berlin Heidelberg}},
  abstract = {We present a formalisation, in the theorem proving system Isabelle/HOL, of a linear type system for the pi calculus, including a proof of runtime safety of typed processes. The use of a uniform encoding of pi calculus syntax in a meta language, the development of a general theory of type environments, and the structured formalisation of the main proofs, facilitate the adaptation of the Isabelle theories and proof scripts to variations on the language and other type systems.},
  isbn = {978-3-540-44755-9},
  keywords = {automatic theorem proving,pi calculus,semantics,Types},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@article{Goto2016a,
  title = {An Extensible Approach to Session Polymorphism},
  author = {Goto, Matthew and Jagadeesan, Radha and Jeffrey, Alan and Pitcher, Corin and Riely, James},
  year = {2016},
  month = mar,
  volume = {26},
  pages = {465--509},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129514000231},
  abstract = {Session types describe and constrain the input/output behaviour of systems. Existing session typing systems have limited support for polymorphism. For example, existing systems cannot provide the most general type for a generic proxy process that forwards messages between two channels. We provide a polymorphic session typing system for the {$\pi$} calculus, and demonstrate the utility of session-type-level functions in combination with polymorphic session typing. The type system guarantees subject reduction and safety properties, but not deadlock freedom. We describe a formalization of the type system in Coq. The proofs of subject reduction and safety properties, as well as typing of example processes, have been mechanically verified.},
  file = {/home/uma/.zotero/data/storage/DIM7IEZM/Goto et al. - 2016 - An extensible approach to session polymorphism.pdf},
  journal = {Mathematical Structures in Computer Science},
  language = {en},
  note = {\url{https://www.cambridge.org/core/product/identifier/S0960129514000231/type/journal_article}},
  number = {3}
}

@inproceedings{Atkey2018,
  title = {Syntax and {{Semantics}} of {{Quantitative Type Theory}}},
  booktitle = {{LICS}},
  author = {Atkey, Robert},
  year = {2018},
  month = jul,
  pages = {56--65},
  publisher = {{ACM}},
  address = {{Oxford United Kingdom}},
  doi = {10.1145/3209108.3209189},
  isbn = {978-1-4503-5583-4},
  language = {en},
  note = {\url{https://dl.acm.org/doi/10.1145/3209108.3209189}}
}

@incollection{McBride2016,
  title = {I {{Got Plenty}} o' {{Nuttin}}'},
  booktitle = {A {{List}} of {{Successes That Can Change}} the {{World}}: {{Essays Dedicated}} to {{Philip Wadler}} on the {{Occasion}} of {{His}} 60th {{Birthday}}},
  author = {McBride, Conor},
  editor = {Lindley, Sam and McBride, Conor and Trinder, Phil and Sannella, Don},
  year = {2016},
  pages = {207--233},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-319-30936-1_12},
  abstract = {Work to date on combining linear types and dependent types has deliberately and successfully avoided doing so. Entirely fit for their own purposes, such systems wisely insist that types depend only on the replicable sublanguage, thus sidestepping the issue of counting uses of limited-use data either within types or in ways which are only really needed to shut the typechecker up. As a result, the linear implication (`lollipop') stubbornly remains a non-dependent \$\$S \textbackslash{}backslashmultimap T\$\$S{$\multimap$}T. This paper defines and establishes the basic metatheory of a type theory supporting a `dependent lollipop' \$\$(x\textbackslash{}backslash!:\textbackslash{}backslash!S)\textbackslash{}backslashmultimap T[x]\$\$(x:S){$\multimap$}T[x], where what the input used to be is in some way commemorated by the type of the output. For example, we might convert list to length-indexed vectors in place by a function with type \$\$(l\textbackslash{}backslash!:\textbackslash{}backslash!\textbackslash{}backslashmathsf \{List\}\textbackslash{}backslash,X)\textbackslash{}backslashmultimap \textbackslash{}backslashmathsf \{Vector\}\textbackslash{}backslash,X\textbackslash{}backslash,(\textbackslash{}backslashmathsf \{length\}\textbackslash{}backslash,l)\$\$(l:ListX){$\multimap$}VectorX(lengthl). Usage is tracked with resource annotations belonging to an arbitrary rig, or `riNg without Negation'. The key insight is to use the rig's zero to mark information in contexts which is present for purposes of contemplation rather than consumption, like a meal we remember fondly but cannot eat twice. We need no runtime copies of l to form the above vector type. We can have plenty of nothing with no additional runtime resource, and nothing is plenty for the construction of dependent types.},
  isbn = {978-3-319-30936-1}
}

@article{Gay2010,
  title = {Linear Type Theory for Asynchronous Session Types},
  author = {Gay, Simon J. and Vasconcelos, Vasco T.},
  year = {2010},
  month = jan,
  volume = {20},
  pages = {19--50},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796809990268},
  abstract = {Session types support a type-theoretic formulation of structured patterns of communication, so that the communication behaviour of agents in a distributed system can be verified by static type checking. Applications include network protocols, business processes, and operating system services. In this paper we define a multithreaded functional language with session types, which unifies, simplifies and extends previous work. There are four main contributions. First: an operational semantics with buffered channels, instead of the synchronous communication of previous work. Second: we prove that the session type of a channel gives an upper bound on the necessary size of the buffer. Third: session types are manipulated by means of the standard structures of a linear type theory, rather than by means of new forms of typing judgement. Fourth: a notion of subtyping, including the standard subtyping relation for session types (imported into the functional setting), and a novel form of subtyping between standard and linear function types which allows the typechecker to handle linear types conveniently. Our new approach significantly simplifies session types in the functional setting, clarifies their essential features, and provides a secure foundation for language developments such as polymorphism and object-orientation.},
  file = {/home/uma/.zotero/data/storage/ULZB8IH7/Gay and Vasconcelos - 2010 - Linear type theory for asynchronous session types.pdf},
  journal = {Journal of Functional Programming},
  language = {en},
  note = {\url{https://www.cambridge.org/core/product/identifier/S0956796809990268/type/journal_article}},
  number = {1}
}

@article{Dybjer1994,
  title = {Inductive Families},
  author = {Dybjer, Peter},
  year = {1994},
  month = jan,
  volume = {6},
  pages = {440--465},
  doi = {10.1007/BF01211308},
  abstract = {A general formulation of inductive and recursive definitions in Martin-L{\"o}f's type theory is presented. It extends Backhouse's `Do-It-Yourself Type Theory' to include inductive definitions of families of sets and definitions of functions by recursion on the way elements of such sets are generated. The formulation is in natural deduction and is intended to be a natural generalisation to type theory of Martin-L{\"o}f's theory of iterated inductive definitions in predicate logic.
Formal criteria are given for correct formation and introduction rules of a new set former capturing definition by strictly positive, iterated, generalised induction. Moreover, there is an inversion principle for deriving elimination and equality rules from the formation and introduction rules. Finally, there is an alternative schematic presentation of definition by recursion.
The resulting theory is a flexible and powerful language for programming and constructive mathematics. We hint at the wealth of possible applications by showing several basic examples: predicate logic, generalised induction, and a formalisation of the untyped lambda calculus.},
  journal = {Formal Aspects of Computing}
}

@inproceedings{Castro2020,
  title = {{{EMTST}}: {{Engineering}} the {{Meta}}-Theory of {{Session Types}}},
  shorttitle = {{{EMTST}}},
  booktitle = {Tools and {{Algorithms}} for the {{Construction}} and {{Analysis}} of {{Systems}}},
  author = {Castro, David and Ferreira, Francisco and Yoshida, Nobuko},
  editor = {Biere, Armin and Parker, David},
  year = {2020},
  pages = {278--285},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-45237-7_17},
  abstract = {Session types provide a principled programming discipline for structured interactions. They represent a wide spectrum of type-systems for concurrency. Their type safety is thus extremely important. EMTST is a tool to aid in representing and validating theorems about session types in the Coq proof assistant. On paper, these proofs are often tricky, and error prone. In proof assistants, they are typically long and difficult to prove. In this work, we propose a library that helps validate the theory of session types calculi in proof assistants. As a case study, we study two of the most used binary session types systems: we show the impossibility of representing the first system in {$\alpha\alpha\backslash$}alpha -equivalent representations, and we prove type preservation for the revisited system. We develop our tool in the Coq proof assistant, using locally nameless for binders and small scale reflection to simplify the handling of linear typing environments.},
  file = {/home/uma/.zotero/data/storage/8WNUY5PM/Castro et al. - 2020 - EMTST Engineering the Meta-theory of Session Type.pdf},
  isbn = {978-3-030-45237-7},
  keywords = {Concurrency,meta-theory,proof assistants,session-types},
  language = {en},
  series = {Lecture {{Notes}} in {{Computer Science}}}
}

@inproceedings{PierceT00,
  author    = {Benjamin C. Pierce and
               David N. Turner},
  editor    = {Gordon D. Plotkin and
               Colin Stirling and
               Mads Tofte},
  title     = {Pict: a programming language based on the Pi-Calculus},
  booktitle = {Proof, Language, and Interaction, Essays in Honour of Robin Milner},
  pages     = {455--494},
  publisher = {The {MIT} Press},
  year      = {2000},
  timestamp = {Mon, 23 Jun 2008 08:52:23 +0200},
  biburl    = {https://dblp.org/rec/conf/birthday/PierceT00.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@book{Henry-Gerard1999,
  title = {Proof of the Subject Reduction Property for a {$\pi$}-Calculus in {{COQ}}},
  author = {{Henry-G{\'e}rard}, Lo{\"i}c and Meije, Projet},
  year = {1999},
  abstract = {This paper presents a method for coding pi-calculus in the COQ proof assistant, in order to use this environment to formalize properties of the pi-calculus. This method consists in making a syntactic discrimination between free names (then called parameters) and bound names (then called variables) of the processes, so that implicit renamings of bound names are avoided in the substitution operation. This technique has been used by J.McKinna and R.Pollack in an extensive study of PTS [5]. We use this coding here to prove subject reduction property for a type system of a monadic pi-calculus.},
  file = {/home/uma/.zotero/data/storage/FVFRE453/summary.html}
}

@article{Honsell2001a,
  title = {Pi-Calculus in ({{Co}}){{Inductive Type Theory}}},
  author = {Honsell, Furio and Miculan, Marino and Scagnetto, Ivan},
  year = {2001},
  volume = {253},
  pages = {2001},
  abstract = {We present a large and we think also significant case-study in computer  assisted formal reasoning. We start by giving a higher order abstract syntax   encoding of \#-calculus in the higher-order inductive/coinductive type  theories CIC and CC  (Co)Ind  . This encoding gives rise to a full-fledged  proof editor/proof assistant for the \#-calculus, once we embed it in Coq,  an interactive proof-development environment for CC  (Co)Ind  . Using this  computerized assistant we prove formally a substantial chapter of the  theory of strong late bisimilarity, which amounts essentially to Section 2  of A calculus of mobile processes by Milner, Parrow, and Walker. This  task is greatly simplified by the use of higher order syntax. In fact, not  only we can delegate conveniently to the metalanguage \#-conversion and  substitution, but, introducing a suitable axiomatization of the theory of  contexts, we can accommodate also the machinery for generating new  names. The axiomatization we introduce is quite general and should be  easily portable to other formalizations based on higher order syntax. The  use of coinductive types and corresponding tactics allows to give alternative,  and possibly more natural, proofs of many properties of strong late  bisimilarity, w.r.t. those originally given by Milner, Parrow, and Walker.  Keywords: higher-order abstract syntax, \#-calculus, proof checking,  Logical Frameworks, typed \#-calculus.},
  file = {/home/uma/projects/references/papers/Honsell et al_2001_pi-calculus in (Co)Inductive Type Theory.pdf;/home/uma/.zotero/data/storage/RE54NCL4/summary.html},
  journal = {Theoretical Computer Science}
}

@book{Bengtson2013,
  title = {The Pi-Calculus},
  author = {Bengtson, Jesper},
  year = {2013},
  abstract = {We formalise the pi-calculus using the nominal datatype package, based on ideas from the nominal logic by Pitts et al., and demonstrate an implementation in Isabelle/HOL. The purpose is to derive powerful induction rules for the semantics in order to conduct machine checkable proofs, closely following the intuitive arguments found in manual proofs. In this way we have covered many of the standard theorems of bisimulation equivalence and congruence, both late and early, and both strong and weak in a uniform manner. We thus provide one of the most extensive formalisations of a the pi-calculus ever done inside a theorem prover. A significant gain in our formulation is that agents are identified up to alpha-equivalence, thereby greatly reducing the arguments about bound names. This is a normal strategy for manual proofs about the picalculus, but that kind of hand waving has previously been difficult to incorporate smoothly in an interactive theorem prover. We show how the nominal logic formalism and its support in Isabelle accomplishes this and thus significantly reduces the tedium of conducting completely formal proofs. This improves on previous work using weak higher order abstract syntax since we do not need extra assumptions to filter out exotic terms and can keep all arguments within a familiar first-order logic.},
  file = {/home/uma/projects/references/papers/Bengtson_2013_The pi-calculus.pdf;/home/uma/.zotero/data/storage/GXM93YGF/summary.html}
}

@book{Despeyroux2000,
  title = {A {{Higher}}-{{Order Specification}} of the {$\pi$}-{{Calculus}}},
  author = {Despeyroux, Jo{\"e}lle},
  year = {2000},
  abstract = {We present a formalization of a typed pi-calculus in the Calculus of Inductive Constructions. We give the rules for type-checking and for evaluation and formalize a proof of type preservation in the Coq system. The encoding of the pi-calculus in Coq uses Coq fonctions to represent bindings of variables. This kind of encoding is called a higher-order specication. It provides a concise description of the calculus, leading to simple proofs. The specification we propose for the pi-calculus formalizes communication by means of function application.},
  file = {/home/uma/.zotero/data/storage/P2ZN3T47/summary.html}
}

@article{Affeldt2008,
  title = {A {{Coq Library}} for {{Verification}} of {{Concurrent Programs}}},
  author = {Affeldt, Reynald and Kobayashi, Naoki},
  year = {2008},
  volume = {199},
  pages = {17--32},
  issn = {1571-0661},
  doi = {10.1016/j.entcs.2007.11.010},
  journal = {Electronic Notes in Theoretical Computer Science}
}

@article{Orchard,
  author    = {Dominic Orchard and
               Vilem{-}Benjamin Liepelt and
               Harley Eades III},
  title     = {Quantitative program reasoning with graded modal types},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {3},
  number    = {{ICFP}},
  pages     = {110:1--110:30},
  year      = {2019},
  doi       = {10.1145/3341714},
  timestamp = {Thu, 16 Apr 2020 13:51:45 +0200},
  biburl    = {https://dblp.org/rec/journals/pacmpl/OrchardLE19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}


@incollection{Georges2017,
  title = {{{LINCX}}: {{A Linear Logical Framework}} with {{First}}-{{Class Contexts}}},
  shorttitle = {{{LINCX}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Georges, Aina Linn and Murawska, Agata and Otis, Shawn and Pientka, Brigitte},
  editor = {Yang, Hongseok},
  year = {2017},
  volume = {10201},
  pages = {530--555},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-662-54434-1_20},
  abstract = {Linear logic provides an elegant framework for modelling stateful, imperative and concurrent systems by viewing a context of assumptions as a set of resources. However, mechanizing the meta-theory of such systems remains a challenge, as we need to manage and reason about mixed contexts of linear and intuitionistic assumptions.},
  file = {/home/uma/.zotero/data/storage/AF75BRT7/Georges et al. - 2017 - LINCX A Linear Logical Framework with First-Class.pdf},
  isbn = {978-3-662-54433-4 978-3-662-54434-1},
  language = {en},
  note = {\url{http://link.springer.com/10.1007/978-3-662-54434-1_20}}
}

@inproceedings{Cervesato1996,
  title = {A {{Linear Logical Framework}}},
  author = {Cervesato, Iliano and Pfenning, Frank},
  year = {1996},
  pages = {264--275},
  publisher = {{IEEE Computer Society Press}},
  abstract = {We present the linear type theory LLF as the forAppeared in the proceedings of the Eleventh Annual IEEE Symposium on Logic in Computer Science --- LICS'96 (E. Clarke editor), pp. 264--275, New Brunswick, NJ, July 27--30 1996.  mal basis for a conservative extension of the LF logical framework. LLF combines the expressive power of dependent types with linear logic to permit the natural and concise representation of a whole new class of deductive systems, namely those dealing with state. As an example we encode a version of Mini-ML with references including its type system, its operational semantics, and a proof of type preservation. Another example is the encoding of a sequent calculus for classical linear logic and its cut elimination theorem. LLF can also be given an operational interpretation as a logic programming language under which the representations above can be used for type inference, evaluation and cut-elimination. 1 Introduction  A logical framework is a formal system desig...},
  file = {/home/uma/projects/references/papers/Cervesato_Pfenning_1996_A Linear Logical Framework.pdf;/home/uma/.zotero/data/storage/CGHAGI96/summary.html}
}

@article{Pientka,
  title = {Cocon: {{Computation}} in {{Contextual Type Theory}}},
  author = {Pientka, Brigitte and Abel, Andreas and Ferreira, Francisco and Thibodeau, David and Zucchini, Rebecca},
  pages = {69},
  abstract = {We describe a Martin-L{\"o}f-style dependent type theory, called Cocon, that allows us to mix the intensional function space that is used to represent higher-order abstract syntax (HOAS) trees with the extensional function space that describes (recursive) computations. We mediate between HOAS representations and computations using contextual modal types. Our type theory also supports an infinite hierarchy of universes and hence supports type-level computation\textemdash{}thereby providing metaprogramming and (small-scale) reflection. Our main contribution is the development of a Kripke-style model for Cocon that allows us to prove normalization. From the normalization proof, we derive subject reduction and consistency. Our work lays the foundation to incorporate the methodology of logical frameworks into systems such as Agda and bridges the longstanding gap between these two worlds.},
  file = {/home/uma/.zotero/data/storage/K5TXLX9V/Pientka et al. - Cocon Computation in Contextual Type Theory.pdf},
  language = {en}
}

@article{Pientkaa,
  title = {A {{Type}}-Theoretic {{Foundation}} for {{Programming}} with {{Higher}}-Order {{Abstract Syntax}} and {{First}}-Class {{Substitutions}}},
  author = {Pientka, Brigitte},
  pages = {12},
  abstract = {Higher-order abstract syntax (HOAS) is a simple, powerful technique for implementing object languages, since it directly supports common and tricky routines dealing with variables, such as capture-avoiding substitution and renaming. This is achieved by representing binders in the object-language via binders in the metalanguage. However, enriching functional programming languages with direct support for HOAS has been a major challenge, because recursion over HOAS encodings requires one to traverse {$\lambda$}abstractions and necessitates programming with open objects.},
  file = {/home/uma/.zotero/data/storage/43TZJCU6/Pientka - A Type-theoretic Foundation for Programming with H.pdf},
  language = {en}
}


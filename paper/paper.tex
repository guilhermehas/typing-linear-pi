\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate,authorcolumns]{lipics-v2019}

\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{todonotes}
\usepackage{enumitem}
\setlist{parsep=0pt,listparindent=\parindent}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsbsy}
\usepackage[many]{tcolorbox}
\bibliographystyle{plainurl}

% Inference rules
\usepackage{mathpartir}

% TODO notes -- TODO: remove
\usepackage{todonotes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Typing a linear \picalc}
\author{Uma Zalakain}{University of Glasgow, Scotland}
       {u.zalakain.1@research.gla.ac.uk}{https://orcid.org/0000-0002-3268-9338}{}
\author{Ornela Dardha}{University of Glasgow, Scotland}
       {ornela.dardha@glasgow.ac.uk}{https://orcid.org/0000-0001-9927-7875}{}
\authorrunning{U. Zalakain and O. Dardha}
\Copyright{Uma Zalakain and Ornela Dardha}
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003753.10003761.10003764</concept_id>
<concept_desc>Theory of computation~Process calculi</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}
\ccsdesc[300]{Theory of computation~Process calculi}
\keywords{pi calculus, linear, types, concurrency}
\supplement{\url{https://github/umazalakain/typing-linear-pi}}
\acknowledgements{I want to thank \dots}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Processes
\newcommand{\PO}{\mathbf{0}}
\newcommand{\comp}[2]{#1 \parallel #2}
\newcommand{\new}{\boldsymbol{\nu} \,}
\newcommand{\send}[2]{#1 \, \langle#2\rangle \,}
\newcommand{\recv}[1]{#1 \, \mathbb{()} \,}

\newcommand{\subst}[3]{#1[#2/#3]}
\newcommand{\picalc}{$\pi$-calculus}
\newcommand{\Picalc}{$\pi$-Calculus}
\newcommand{\reduce}{\longrightarrow}
\newcommand{\types}[4]{#1 \propto #2 \vdash #3 \boxtimes #4}
\newcommand{\suc}{{\scriptscriptstyle 1+}}

% Types
\newcommand{\Var}{\mathrm{VAR}}
\newcommand{\Process}{\mathrm{PROCESS}}
\newcommand{\Unused}{\mathrm{UNUSED}}
\newcommand{\PreCtx}{\mathrm{PRECTX}}
\newcommand{\Ctx}{\mathrm{CTX}}
\newcommand{\Type}{\mathrm{TYPE}\;}
\newcommand{\Idx}{\mathrm{IDX}\;}
\newcommand{\Idxs}{\mathrm{IDXS}}
\newcommand{\Carrier}{\mathrm{CARRIER}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Channel}{\mathrm{CHANNEL}}
\newcommand{\Rec}{\mathrm{REC}}


\begin{document}

\maketitle
\todo{remove todo notes}

\begin{abstract}
  We present the syntax, operational semantics, and typing rules of a \picalc{} with linear and shared types.
  We use leftover typing \cite{Allais2018a} to encode our typing rules in a way that propagates linearity constraints into process continuations.
  We generalize the algebras on multiplicities using indexed sets of \emph{partial commutative monoids}, allowing the user to choose a mix of linear, affine, gradual and shared typing.
  We provide framing, weakening and strengthening proofs that we then use to prove subject congruence.
  We show that the type system is stable under substitution and prove subject reduction.

  This formalization has been fully mechanized with Agda and is available at \url{https://github.com/umazalakain/typing-linear-pi}.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

The \picalc models communication.

why resource-aware typing

extensional typing rules for a given syntax and operational semantics

leftover typing

\subsection{Contribution}

\begin{description}
  \item [Machine verified formalisation of the linear pi calculus]

  \item [Typing with leftovers applied to the pi calculus]

  \item [Abstraction over multiplicities]

  \item [Full formalisation available in Agda]
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related work}

\cite{previous-work} polymorphic tokens, HOAS

\cite{typing-with-leftovers}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax}

variable references (strings, locally named, de Bruijn)

allows to ignore alpha conversion, or proofs of inequality between strings

strings to maybe de Bruijn, names can be kept in context as well, just not doing it

\begin{figure}[h]
\begin{mathpar}
  {\mprset{fraction={===}}
    \inferrule
    {n : \N}
    {\Var_n : Set}}

  \inferrule
  {n : \N}
  {0 : \Var_n}

  \inferrule
  {x : \Var_n}
  {\suc x : \Var_{\suc n}}
\end{mathpar}
\caption{Types of size $n$}
\end{figure}

\begin{figure}[h]
\begin{mathpar}
  {\mprset{fraction={===}}
    \inferrule
    {n : \N}
    {\Process_n : Set}}
\end{mathpar}
  
\begin{equation*} \label{pi-calc-syntax}
\begin{split}
  \Process_n ::=& \; \PO_n                    \\
              |& \; \new{} \Process_{\suc n}          \\
              |& \; \comp{\Process_n}{\Process_n}          \\
              |& \; \recv{\Var_n}{}\Process_{\suc n} \\
              |& \; \send{\Var_n}{\Var_n}\Process_n
\end{split}
\end{equation*}
\caption{Well-scoped grammar using de Bruijn indices}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semantics}

\subsection{Structural congruence}

\begin{figure}[h]
\begin{mathpar}
  {\mprset{fraction={===}}
    \inferrule
    {P \, Q : \Process_n}
    {P \equiv_n Q : Set}}

  \inferrule
  {P \; Q \; R : \Process_n}
  {comp-assoc : \comp{P}{\comp{Q}{R}} \equiv_n \comp{\comp{P}{Q}}{R}}

  \inferrule
  {P \; Q : \Process_n}
  {comp-sym : \comp{P}{Q} \equiv_n \comp{Q}{P}}
  
  \inferrule
  {P : \Process_n}
  {comp-end : \comp{P}{\PO_n} \equiv_n P}
  
  \inferrule
  { }
  {scope-end : \new \PO_{\suc n} \equiv_n \PO_n}
  
  \inferrule
  {P \, Q : \Process_{\suc n} \\ uQ : \Unused_0 \, Q}
  {scope-ext : \new (\comp{P}{Q}) \equiv_n \comp{(\new P)}{lower \; 0 \; \; Q \; uQ}}

  \inferrule
  {P : \Process_{\suc \suc n}}
  {scope-comm : \new \new P \equiv_n \new \new swap \; 0 \; P}
\end{mathpar}
\caption{Structural rewriting rules}
\end{figure}

\begin{figure}[h]
\begin{mathpar}
  \mprset{flushleft}
  
  {\mprset{fraction={===}}
    \inferrule
    { }
    {\Rec : Set}}

  \inferrule
  { }
  {zero : \Rec}
  
  \inferrule
  {r : \Rec}
  {one \; r : \Rec}

  \inferrule
  {r \; s : \Rec}
  {two \; r \; s : \Rec}
  
  {\mprset{fraction={===}}
    \inferrule
    {P \, Q : \Process_n \\ r : \Rec}
    {P =_r Q : Set}}

  \inferrule
  {P \; Q : \Process_n \\ P \equiv_n Q}
  {struct : P =_{zero} Q}

  \inferrule
  {P \; P' : \Process_{\suc n} \\ P =_r P'}
  {cong-scope : \new P =_{one \; r} \new P'}

  \inferrule
  {P \; P' : \Process_n \\ P =_r P'}
  {cong-comp : \comp{P}{Q} =_{one \; r} \comp{P'}{Q}}

  \inferrule
  {P \; P' : \Process_{\suc n} \\ P =_r P'}
  {cong-recv : \recv{x}P =_{one \; r} \recv{x}P'}

  \inferrule
  {P \; P' : \Process_n \\ P =_r P'}
  {cong-send : \send{x}{y}P =_{one \; r} \send{x}{y}P'}

  \inferrule
  {P : \Process_n}
  {refl : P =_{zero} P}

  \inferrule
  {P \; Q : \Process_n \\ P =_r Q}
  {sym : Q =_{one \; r} P}

  \inferrule
  {P \; Q \; R : \Process_n \\ P =_r Q \\ Q =_s R}
  {trans : P =_{two \; r \; s} R}
\end{mathpar}
\caption{Structural rewriting rules lifted to a congruent equivalence relation}
\end{figure}
  

congruence relationship indexed by recursive tree

\subsection{Reduction}

\begin{figure}[h]
\begin{mathpar}
  {\mprset{fraction={===}}
    \inferrule
    {n : \N}
    {\Channel_n : Set}}

  \inferrule
  { }
  {nothing : \Channel_n}

  \inferrule
  {i : \Var_n}
  {just \; i : \Channel_n}

  {\mprset{fraction={===}}
    \inferrule
    {i : \Channel_n \\ P \; Q : \Process_n}
    {P \reduce_i Q : Set}}

  \inferrule
  {i \; j : \Var_n \\ P : \Process_{\suc n} \\ Q : \Process_n \\ uP : \Unused_0 \, P}
  {comm : \comp{\recv{i}P}{\send{i}{j}{Q}} \reduce_{just \; i} \comp{lower \; 0 \; \subst{P}{j}{0} \; uP}{Q}}

  \inferrule
  {P \reduce_i P'}
  {par : \comp{P}{Q} \reduce_i \comp{P'}{Q}}

  \inferrule
  {P \reduce_i Q}
  {res : \new P \reduce_{dec\; i} \new Q}

  \inferrule
  {P = P' \\ P' \reduce_i Q}
  {struct : P \reduce_i Q}
\end{mathpar}
\caption{Operational semantics indexed by reducing channel}
\end{figure}

keeping track of the variable on which communication occurs


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linear typing rules}

\subsection{Multiplicities}

A type system with both linear and shared resources has multiplicities $0$, $1$ and $\omega$.

\subsection{Variable references}


\subsection{Contexts}

\begin{figure}[h]
\begin{mathpar}
  {\mprset{fraction={===}}
    \inferrule
    {n : \N}
    {\PreCtx_n : Set}
  }

  \inferrule
  { }
  {[] : \PreCtx_0}

  \inferrule
  {\gamma : \PreCtx_n \\ t : \Type}
  {\gamma , t : \PreCtx_{\suc n}}
\end{mathpar}
\end{figure}
  
\begin{figure}[h]
\begin{mathpar}
  {\mprset{fraction={===}}
    \inferrule
    {n : \N}
    {\Idxs_n : Set}}

  \inferrule
  { }
  {[] : \Idxs_0}

  \inferrule
  {\imath : \Idxs_n \\ x : \Idx}
  {\imath , x : \Idxs_{\suc n}}

  \\
  
  {\mprset{fraction={===}}
    \inferrule
    {\imath : \Idxs n}
    {\Ctx_\imath : Set}}
  
  \inferrule
  { }
  {[] : Ctx_{[]}}
  
  \inferrule
  {\Gamma : \Ctx_\imath \\ c : \Carrier_x}
  {\Gamma , c : \Ctx_{\imath , x}}
\end{mathpar}
\end{figure}
two-layered approach: types on one hand, capabilities on the other
removing from context vs keeping in context but marking it used

\subsection{Typing with leftovers}

\subsubsection{Typing relation}

Variable references as proofs of capability

Context splits at each variable reference

\begin{figure}[h]
\begin{mathpar}
  {\mprset{fraction={===}}
    \inferrule{
      \gamma : \PreCtx_n \\
      \inferrule*{}{
        \imath : \Idxs_n \\\\
        \Gamma : \Ctx_\imath} \\
      P : \Process_n \\
      \Delta : \Ctx_\imath}
    {\types{\gamma}{\Gamma}{P}{\Delta} : Set}}
  
\end{mathpar}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subject reduction}

\subsection{Framing}


\subsection{Weakening}

Suffices to model as a series of insertions.

\subsection{Strengthening}

\subsection{Swapping}

\subsection{Substitution}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future work}

Work that will be done time permiting:

\begin{description}

\item [Affine types]
  
\item [Proof of progress]

\item [Product types]

\item [Sum types]

\item [Decidable typechecking]

\item [Soundness and completeness with respect to an alternative formalization.]

\item [Encoding of session types]

\end{description}


\bibliography{paper}
\end{document}

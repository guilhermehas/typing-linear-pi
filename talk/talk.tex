\documentclass[dvipsnames]{beamer}

\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsbsy}
\usepackage{mathbbol}
\usepackage{mathtools}

% Diagrams
\usepackage{tikz}

% Mathbb doesn't support digits
\usepackage{bbm}

% Example code
\usepackage{listings}

% Inference rules
\usepackage{mathpartir}

% Multiple columns
\usepackage{multicol}

% Do not use italics in definitions and theorems
\theoremstyle{definition}
\newtheorem{nidefinition}{Definition}
\newtheorem{nitheorem}{Theorem}
\newtheorem{nilemma}{Lemma}

% Abbreviations
\newcommand{\lambdacalc}{$\lambda$-calculus}
\newcommand{\picalc}{$\pi$-calculus}
\newcommand{\Picalc}{$\pi$-Calculus}

% Typing rules
\newcommand{\stacked}[1]{\mprset{flushleft} \inferrule*{}{#1}}
\newcommand{\datatype}[2]{{\mprset{fraction={===}} \inferrule{#1}{#2}}}

\newcommand{\type}[1]{\textcolor{BlueViolet}{\operatorname{#1}}}
\newcommand{\constr}[1]{\textcolor{BurntOrange}{\operatorname{#1}}}
\newcommand{\func}[1]{\textcolor{OliveGreen}{\operatorname{#1}}}

% Constructors
\newcommand{\PO}{\constr{\mathbb{0}}}
\newcommand{\comp}[2]{#1 \; \constr{\parallel} \; #2}
\newcommand{\new}{\constr{\boldsymbol{\nu}} \;}
\newcommand{\send}[2]{#1 \; \constr{\langle} \; #2 \;\constr{\rangle} \;}
\newcommand{\sendp}[2]{#1 \; \constr{\langle} \; #2 \; \constr{\rangle} \; . \;}
\newcommand{\recv}[1]{#1 \; \constr{\mathbb{()}} \;}
\newcommand{\recvp}[2]{#1 \; \constr{(} \; #2 \; \constr{)} \; . \; }
\newcommand{\suc}{\constr{\scriptstyle 1+}}
\newcommand{\unit}{\constr{\mathbbm{1}}}
\newcommand{\base}[1]{\constr{B[} \; #1 \; \constr{]}}
\newcommand{\channel}[2]{\constr{C[} \; #1 \; \constr{;} \; #2 \; \constr{]}}
\newcommand{\comma}{\; \constr{,} \;}

% Functions
\newcommand{\subst}[3]{#1 \; \func{[} \; #3 \; \func{\mapsto} \;#2 \; \func{]}}
\newcommand{\op}[3]{#1 \; \func{\coloneqq} \; #2 \; \func{\cdot} \; #3}
\newcommand{\opsquared}[3]{#1 \, \func{\coloneqq} \, #2 \, \func{\cdot^2} \, #3}
\newcommand{\opctx}[3]{#1 \, \func{\coloneqq} \, #2 \, \func{\otimes} \, #3}
\newcommand{\zero}{\func{0\cdot}}
\newcommand{\one}{\func{1\cdot}}
\newcommand{\li}{\func{\ell_i}}
\newcommand{\lo}{\func{\ell_o}}
\newcommand{\lz}{\func{\ell_{\o}}}
\newcommand{\lio}{\func{\ell_{\#}}}

% Types
\newcommand{\Set}{\type{SET}}
\newcommand{\reduce}[1]{\; \type{\longrightarrow}_{#1} \;}
\newcommand{\types}[4]{#1 \; \type{;} \; #2 \; \type{\vdash} \; #3 \; \type{\triangleright} \; #4}
\newcommand{\contains}[6]{#1 \; \type{;} \; #2 \; \type{\ni}_{#3} \; #4 \; \type{;} \; #5 \; \type{\triangleright} \; #6}
\newcommand{\containsusage}[4]{#1 \; \type{\ni}_{#2} \; #3 \; \type{\triangleright} \; #4}
\newcommand{\Var}{\type{VAR}}
\newcommand{\Process}{\type{PROCESS}}
\newcommand{\Unused}{\type{UNUSED}}
\newcommand{\PreCtx}{\type{PRECTX}}
\newcommand{\Ctx}{\type{CTX}}
\newcommand{\Type}{\type{TYPE}\;}
\newcommand{\Idx}{\type{IDX}\;}
\newcommand{\Idxs}{\type{IDXS}}
\newcommand{\Usage}{\type{USAGE}}
\newcommand{\N}{\type{\mathbb{N}}}
\newcommand{\Channel}{\type{CHANNEL}}
\newcommand{\Rec}{\type{REC}}
\newcommand{\Algebra}{\type{ALGEBRA}}
\newcommand{\eq}[1]{\; \type{\simeq}_{#1} \;}
\newcommand{\eqeq}{\; \type{\cong} \;}

\usetheme[sectionpage=none,numbering=none]{metropolis}
\setbeamertemplate{title separator}{}
\date{}

\title{$\pi$ with leftovers: \\ a mechanisation in Agda}
\author{\textbf{Uma Zalakain} \ and \  Ornela Dardha \\ University of Glasgow}

\begin{document}
  \maketitle

  \note[itemize]{
  \item Please interrupt at any time
  }

  \begin{frame}{Motivation}
    \begin{itemize}
    \item \picalc{} as a computational model for communication and concurrency
    \item Linear type systems guarantee that resources are used exactly once
    \item Combining them both gives raise to session types
    \item Underlying framework
    \end{itemize}
  \end{frame}

  \begin{frame}{Constraints}
    \centering
    \begin{tikzpicture}
      \node[draw, rounded corners] (st) at (0,0) {session-typed \picalc{}};
      \node[draw=red, thick, rounded corners, label={[red]below:\textasciicircum this\textasciicircum}] (sh) at (5,0) {linear \picalc{}};
      \draw[->, thick] (st) -- (sh);
    \end{tikzpicture}
    \vspace{2em}

    \begin{itemize}
      \item Syntax and semantics must be untyped
      \item Must also support shared channels
      \item Goal: to prove subject reduction
    \end{itemize}
  \end{frame}

  \note[itemize]{
  \item We want to encode the session-typed \picalc{} into the linear \picalc{}
  \item and prove some properties of the encoding
  \item We first need our target language: the linear \picalc{}
  \item Common syntax and semantics for linear and session-typed
  }
  
  \begin{frame}{Notation}
    \begin{equation*}
      \begin{aligned}
        & \type{TYPES}          && \text{blue violet, uppercased, indices as subscripts} \\
        & \constr{constructors} && \text{burnt orange} \\
        & \func{functions}      && \text{olive green} \\
        & variables             && \text{black, in italics} \\
      \end{aligned}
    \end{equation*}
  \end{frame}

  \begin{frame}{\Picalc{}: Well-Scoped Syntax}
    \begin{mathpar}
      \inferrule
      {n : \N}
      {\constr{0} : \Var_{\suc n}}

      \inferrule
      {x : \Var_n}
      {\suc x : \Var_{\suc n}}
    \end{mathpar}

    \begin{equation*}
      \begin{aligned}
        \Process_n ::=& \; \PO_n               &&\text{(inaction)}    \\ 
        |& \; \new{} \Process_{\suc n}         &&\text{(restriction)} \\ 
        |& \; \comp{\Process_n}{\Process_n}    &&\text{(parallel)}     \\ 
        |& \; \recv{\Var_n}{}\Process_{\suc n} &&\text{(input)}       \\ 
        |& \; \send{\Var_n}{\Var_n}\Process_n  &&\text{(output)}       \\           
      \end{aligned}
    \end{equation*}

    TODO: example named, example de Bruijn
  \end{frame}

  \note[itemize]{
    \item \picalc{} syntax, well-scoped by construction through de Bruijn indices
    \item go over the constructors
  }

  \begin{frame}{\Picalc{}: Structural Congruence}
    \begin{mathpar}
      \inferrule
      { }
      {\constr{comp-assoc} : \comp{P}{(\comp{Q}{R})} \eqeq \comp{(\comp{P}{Q})}{R}}

      \inferrule
      { }
      {\constr{comp-sym} : \comp{P}{Q} \eqeq \comp{Q}{P}}
      
      \inferrule
      { }
      {\constr{comp-end} : \comp{P}{\PO_n} \eqeq P}
      
      \inferrule
      { }
      {\constr{scope-end} : \new \PO_{\suc n} \eqeq \PO_n}
      
      \inferrule
      {uQ : \Unused_{\constr{0}} \; Q}
      {\constr{scope-ext} : \new (\comp{P}{Q}) \eqeq \comp{(\new P)}{\func{lower}_{\constr{0}} \; \; Q \; uQ}}

      \inferrule
      { }
      {\constr{scope-comm} : \new \new P \eqeq \new \new \func{swap}_{\constr{0}} \; P}
    \end{mathpar}

    \centering
    $\eq{}$ is the congruent equivalence closure of $\eqeq$
  \end{frame}

  \note[itemize]{
    \item Parallel composition is associative, commutative and has $\PO$ as neutral element
    \item Garbage collection
    \item Scope extrusion (keep a proof $uQ$ alongside)
    \item Commutativity of scopes
  }

  \begin{frame}{\Picalc{}: Reduction Relation}
    \begin{mathpar}
      \inferrule
      { }
      {\constr{internal} : \Channel_n}

      \inferrule
      {i : \Var_n}
      {\constr{external} \; i : \Channel_n}

      \inferrule
      {i \; j : \Var_n \\ P : \Process_{\suc n} \\ Q : \Process_n}
      {\constr{comm} : \comp{\recv{i}P}{\send{i}{j}{Q}} \reduce{\constr{external} \; i} \comp{\func{lower}_{\constr{0}} \; (\subst{P}{\suc j}{\constr{0}}) \; uP'}{Q}}

      \inferrule
      {red : P \reduce{c} P'}
      {\constr{par} \; red : \comp{P}{Q} \reduce{c} \comp{P'}{Q}}

      \inferrule
      {red : P \reduce{c} Q}
      {\constr{res} \; red : \new P \reduce{\func{dec}\; c} \new Q}

      \inferrule
      {eq : P \eq{} P' \\ red : P' \reduce{c} Q}
      {\constr{struct} \; eq \; red : P \reduce{c} Q}
    \end{mathpar}
  \end{frame}

  \note[itemize]{
    \item Same scope before and after reduction
    \item Scope restriction is preserved (can be eliminated in strictly linear systems)
    \item Common channel $i$
    \item We keep track of $i$ at the type level
    \item Goes under parallel composition and scope restriction
    \item $\func{dec}$ saturates on $\constr{internal}$
  }

  \begin{frame}[t]
    \begin{columns}[T]
      \begin{column}{0.5\textwidth}
        \centering
        \vspace*{10em}
        Untyped syntax \\
        Operational semantics
        \vspace*{10em}
      \end{column}
      \vrule width 2pt
      \begin{column}{0.5\textwidth}
        \centering
        \vspace*{10em}
        Type system
        \vspace*{10em}
      \end{column}
    \end{columns}
  \end{frame}
    
  \begin{frame}{Type System}
    \begin{itemize}
      \item Syntax directed
      \item Independent type and usage contexts
      \item Extra leftover usage context
      \item Intrinsic context splits
      \item Based on a set of usage algebras
    \end{itemize}
  \end{frame}
  
  \note[itemize]{
  \item Only choice is in the types and usage annotations on scope restriction
  \item A syntax directed type system allows for inversion lemmas
  \item More on intrinsic/extrinsic later
  \item Linear, graded and shared types are all instances of an usage algebra
  }

  \begin{frame}{Usage Algebra}
    \begin{equation*}
    \begin{aligned}
      &\zero                  &:{} &                 &        & C \\
      &\one                   &:{} &                 &        & C \\
      &\op{\_}{\_}{\_}        &:{} &                 &        & C \to C \to C \to \Set \\
      &\func{\cdot-id^l}      &:{} &\forall x         & \to \; & \op{x}{\zero}{x} \\
      &\func{\cdot-assoc}     &:{} &\forall x y z u v & \to \; & \op{x}{y}{z} \to \op{y}{u}{v} \to \\
      &                       &    &                  &        & \type{\exists} w  \; (\op{x}{u}{w} \times \op{w}{v}{z}) \\
      &\func{\cdot-comm}      &:{} &\forall x y z     & \to \; & \op{x}{y}{z} \to \op{x}{z}{y} \\
      &\func{\cdot-min^l}     &:{} &\forall y z        & \to \; & \op{\zero}{y}{z} \to y \equiv \zero \\
      &\func{\cdot-unique}    &:{} &\forall x x' y z  & \to \; & \op{x'}{y}{z} \to \op{x}{y}{z} \to x' \equiv x \\
      &\func{\cdot-unique^l}  &:{} &\forall x y y' z  & \to \; & \op{x}{y'}{z} \to \op{x}{y}{z} \to y' \equiv y \\
      &\func{\cdot-compute^r} &:{} &\forall x y       & \to \; & \type{DEC} \; (\type{\exists} z  \; (\op{x}{y}{z})) \\
    \end{aligned}
    \end{equation*}
  \end{frame}

  \note[itemize]{
    \item Model as a ternary relation
    \item Decidable, deterministic, cancellative and has a minimal element
  }

  \begin{frame}{Notation}
    \textbf{Capability} input / output
    \hspace{2em}
    \textbf{Multiplicity} $\zero$, $\one$, \ldots

    \begin{equation*}
      \begin{aligned}
        &C^{\func{2}} &&= C \type{\times} C \\
        &\lz          &&= \zero \comma \zero \\
        &\li          &&= \one \comma \zero \\
        &\lo          &&= \zero \comma \one \\
        &\lio         &&= \one \comma \one \\
        &\opsquared{(x_l \comma x_r)}{(y_l \comma y_r)}{(z_l \comma z_r)} &&= (\op{x_l}{y_l}{z_l}) \times (\op{x_r}{y_r}{z_r}) \\
      \end{aligned}
    \end{equation*}
  \end{frame}

  \note[itemize]{
  \item Notation borrowed from linear \picalc{}
  \item We use two carriers per channel: one for input, one for output
  }
  
  \begin{frame}{Indexed Usage Algebras}
    \begin{equation*}
      \begin{aligned}
        &\Idx               &: &\Set \\
        &\type{\exists IDX} &: &\Idx \\
        &\Usage             &: &\Idx \to \Set \\
        &\type{ALGEBRAS}    &: &(idx : \Idx) \to \Algebra_{\Usage_{idx}} \\
      \end{aligned}
    \end{equation*}

    TODO
  \end{frame}

  \note[itemize]{
    \item Lump multiple algebras together
  }
  
  \begin{frame}{Types}
    \begin{mathpar}
      \inferrule
      { }
      {\unit : \Type}

      \inferrule
      {n : \N}
      {\base{n} : \Type}
      
      \inferrule
      {t : \Type \\ \stacked{idx : \Idx \\\\ x : \Usage_{idx}^{\func{2}}}}
      {\channel{t}{x} : \Type}
    \end{mathpar}

    \centering
    \vfill{}
    \textit{e.g.} $\channel{\channel{\unit}{\omega}}{\li}$
  \end{frame}

  \begin{frame}{Type System}
    \begin{description}
    \item [$\PreCtx_n$] list of $\Type$s of length $n$
    \item [$\Idxs_n$] list of $\Idx$s of length $n$
    \item [$\Ctx_{idxs}$] list of $\Usage^{\func{2}}$s indexed over $idxs  \; : \Idxs_n$
    \end{description}
    
    \small
    \begin{mathpar}
    \datatype{
      \gamma : \PreCtx_n \\
      \stacked{
        idxs : \Idxs_n \\\\
        \Gamma : \Ctx_{idxs}} \\
      P : \Process_n \\
      \Delta : \Ctx_{idxs}}
    {\types{\gamma}{\Gamma}{P}{\Delta} : \Set}
    \end{mathpar}
  \end{frame}

  \note[itemize]{
  \item Typing judgment through typing relations
  \item One relation on processes, one relation on variable references (omitted for brevety)
  \item Relation on variable references uses the monoid to split multiplicities
  }
  
  \begin{frame}{Typing Rules}
    \begin{mathpar}
      \inferrule
    {l \hspace{0.2em} : \types{\gamma}{\Gamma \hspace{0.3em}}{P}{\Delta} \\\\
      r : \types{\gamma}{\Delta}{Q}{\Xi}}
    {\constr{comp} \; l \; r : \types{\gamma}{\Gamma}{\comp{P}{Q}}{\Xi}}

    \inferrule
    { }
    {\constr{end} : \types{\gamma}{\Gamma}{\PO}{\Gamma}}
  
    \end{mathpar}
  \end{frame}
  
  \note[itemize]{
  \item Instead of one authoritative context split, give decision power to P
  }

  \begin{frame}{Typing Rules}
    \begin{mathpar}
    \inferrule
    {t : \Type \\ x : \Usage_{idx}^{\func{2}} \\ y : \Usage_{idx'} \\\\
      cont : \types{\gamma \comma \channel{t}{x}}{\Gamma \comma (y \comma y) }{P}{\Delta \comma \lz}}
    {\constr{chan} \; t \; x \; y \; cont : \types{\gamma}{\Gamma}{\new P}{\Delta}}

    \inferrule
        {\stacked{
            chan_i : \contains{\gamma \hspace{1.2em}}{\Gamma \hspace{1.5em}}{i}{\channel{t}{x}}{\li}{\Xi} \\\\
            cont \hspace{0.4em} : \types{\gamma \comma t}{\Xi \comma x}{P \hspace{4.6em}}{\Theta \comma \lz}}}
        {\constr{recv} \; chan_i \; cont : \types{\gamma}{\Gamma}{\recv{i}{P}}{\Theta}}
  
    \inferrule
        {\ldots}
        {\constr{send} \; \ldots}
  
    \end{mathpar}
  \end{frame}

  \note[itemize]{
  \item Newly introduced channels are balanced
  \item The multiplicities of new variables must be exhausted
  }

  \begin{frame}{Type System: Initial Pitfalls}
    TODO: alternatives detour
    
    \begin{itemize}
    \item Using functions to update usage contexts
      \begin{mathpar}
        \inferrule
        {\stacked{
            \gamma \; \type{;} \; \Gamma \; \type{\ni}_i \; \channel{t}{u} \; \type{;} \; x\\
            \opsquared{x}{\li}{z} \\\\
            \gamma \comma t \; \type{;} \; (\func{update}_i \; z \; \Gamma) \comma u \vdash P}}
        {\gamma \; \type{;} \; \Gamma \; \type{\vdash} \; \recv{i}{P}}
      \end{mathpar}
    \item Extrinsic context splits
      \begin{mathpar}
        \inferrule
        {\stacked{
            \opctx{\Gamma}{\Delta}{\Xi} \\\\
            \gamma \; \type{;} \; \Delta \; \type{\vdash} P \\\\
            \gamma \; \type{;} \; \Xi \; \type{\vdash} Q}}
        {\gamma \; \type{;} \; \Gamma \; \type{\vdash} \; \comp{P}{Q}}
      \end{mathpar}
    \end{itemize}
  \end{frame}

  \note[itemize]{
  \item The extrinsic context split is authoritative, P already knows what it needs
  }

  \begin{frame}
    MEME
  \end{frame}
  
  \begin{frame}{Type Safety: Subject Congruence}
    \begin{description}
      \item [Framing] The well-typedness of a process is independent of its leftover resources.

      \item [Weakening] Inserting a new variable into the context preserves the well-typedness of a process as long as the usage annotation of the inserted variable is preserved as a leftover.

      \item [Strengthening] Removing an unused variable preserves the well-typedness of a process.

      \item [Subject congruence] Applying structural congruence rules to a well typed process preserves its well-typedness.
    \end{description}
  \end{frame}

  \note[itemize]{
  \item First three by induction on \textsc{Types} and \textsc{VarRef}
  \item First three state for the first time for the \picalc{}
  }

  \begin{frame}{Type Safety: Substitution}
    TODO: dumbed down
    TODO: emphasis on easy paper, tricky mechanise
  \end{frame}

  \note[itemize]{
  \item We got rid of the types in the judgments
  \item Comment on parallel composition case, similar to input and output
  }

  \begin{frame}{Type Safety: Subject Reduction}
    \begin{nitheorem}[Subject reduction]
      \label{thm:subject-reduction}
      Let $P$ be well typed in $\types{\gamma}{\Gamma}{P}{\Xi}$ and reduce such that $P \reduce{c} Q$.
      \begin{itemize}
      \item If $c$ is $\constr{internal}$, then $\types{\gamma}{\Gamma}{Q}{\Xi}$.
      \item If $c$ is $\constr{external} \; i$ and $\containsusage{\Gamma}{i}{\lio}{\Delta}$, then $\types{\gamma}{\Delta}{Q}{\Xi}$.
      \end{itemize}
    \end{nitheorem}
  \end{frame}

  \begin{frame}{Future Work}
    \begin{itemize}
    \item Prove preservation of well-balancedness
    \item Product types
    \item Sum types
    \item Recursion
    \item Bidirectional type system
    \item Decidable type checking
    \item Use as target language for the session-typed \picalc{}
    \end{itemize}
  \end{frame}

  \begin{frame}
    \centering
    \Huge{Thank you!} \\
    \Huge{\textasciicircum \_\textasciicircum} \\
    \Huge{Questions?}
  \end{frame}
    

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  

  \begin{frame}{Variable References}
    \begin{mathpar}
      \inferrule
      {\opsquared{x}{y}{z}}
      {\constr{0} : \contains{\gamma \comma t}{\Gamma \comma x}{\constr{0}}{t}{y}{\Gamma \comma z}}
      
      \inferrule
      {\hspace{-0.1em} loc_i : \contains{\gamma \hspace{1.4em}}{\Gamma \hspace{1.7em}}{\hspace{1em} i}{t}{x}{\Delta}}
      {\suc \; loc_i : \contains{\gamma \comma t'}{\Gamma \comma x'}{\suc i}{t}{x}{\Delta \comma x'}}
    \end{mathpar}
  \end{frame}

  \note[itemize]{
  \item Constructor completely determined by $i$
  \item User alleviated from proof burden $\opsquared{x}{y}{z}$, which can be computed given $x$ and $y$
  }
  
  \begin{frame}{Type Safety: Substitution}
    \begin{nitheorem}[Substitution with accumulator]
      Let $\types{\gamma}{\Gamma_i}{P}{\Psi_i}$.
      Let there be some $\Gamma$, $\Psi$, $\Gamma_j$ and $\Psi_j$ such that:
      \setlength{\linewidth}{.8\linewidth}
      \begin{multicols}{2}
        \begin{itemize}
        \item $\contains{\gamma}{\Gamma_i}{i}{t}{m}{\Gamma}$
        \item $\contains{\gamma}{\Gamma_j}{j}{t}{m}{\Gamma}$
        \item $\contains{\gamma}{\Psi_i}{i}{t}{n}{\Psi}$
        \item $\contains{\gamma}{\Psi_j}{j}{t}{n}{\Psi}$
        \end{itemize}
        \vfill\null
        \columnbreak
        \scriptsize
        \begin{tikzpicture}
          \node (gamma-i) at (0,3)   {$\Gamma_i$};
          \node (gamma-m) at (0,1.5)   {$\Gamma$};
          \node (gamma-j) at (0,0)   {$\Gamma_j$};
          \node (xi-i)    at (2.5,2.75) {$\Xi_i$};
          \node (theta)   at (2.5,1.75) {$\Theta$};
          \node (delta-m) at (2.5,1.25) {};
          \node (xi-j)    at (2.5,0.25) {$\Xi_j$};
          \node (psi-i)   at (5,2.5)   {$\Psi_i$};
          \node (psi-m)   at (5,1.5)   {$\Psi$};
          \node (psi-j)   at (5,0.5)   {$\Psi_j$};

          \draw[-]  (gamma-m) -- (delta-m.center);
          \draw[->] (delta-m.center) -- node[align=center,below] {$\Delta$\\$\Delta_i = \lz$}(psi-m);

          \draw[->,densely dotted] (gamma-m) -- (theta);
          \draw[->,densely dotted] (theta) -- (psi-m);
          
          \draw[->] (gamma-i) -- node[left] {$\ni_i m$} (gamma-m);
          \draw[->] (gamma-j) -- node[left] {$\ni_j m$} (gamma-m);
          \draw[->] (psi-i) -- node[right] {$\ni_i n$} (psi-m);
          \draw[->] (psi-j) -- node[right] {$\ni_j n$} (psi-m);

          \draw[->] (gamma-i) -- node[above] {$\vdash L$} (xi-i);
          \draw[->] (xi-i) -- node[above] {$\vdash R$} (psi-i);
          \draw[->,densely dotted] (gamma-j) -- node[below] {$\vdash \subst{L}{j}{i}$} (xi-j);
          \draw[->,densely dotted] (xi-j) -- node[below] {$\vdash \subst{R}{j}{i}$} (psi-j);
          \draw[->,densely dotted] (xi-i) -- node[left] {$\ni_i l$} (theta);
          \draw[->,densely dotted] (xi-j) -- node[left] {$\ni_j l$} (theta);
        \end{tikzpicture}
      \end{multicols}
      Let there be some $\Delta$ such that $\opctx{\Gamma}{\Delta}{\Psi}$.
      Let $\Delta$ have usage $\lz$ at position $i$.
      Then $\types{\gamma}{\Gamma_j}{\subst{P}{j}{i}}{\Psi_j}$.
    \end{nitheorem}
  \end{frame}
\end{document}